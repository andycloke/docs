---
title: "Response JMESPath"
---

Transform your API responses with JMESPath, a powerful query language that helps you extract and reshape JSON data before it reaches Airtable. Use JMESPath to keep only the fields you need, rename confusing field names, filter data based on conditions, and work with nested structures.

## **How to set up Response JMESPath**

1. On the request screen, click the **Advanced Settings** button to expand additional options.
2. Scroll down to the **Response JMESPath** field and enter your expression.
3. Run your request again to see the transformed data, then reconfigure your response field mappings to match the new JSON structure.

<video
  controls
  className="w-full aspect-video rounded-xl"
  src="/videos/Response jmespath.mp4"
></video>

<Note>
  You can [copy the response
  JSON](/create-requests/response-field-mapping#working-with-response-data) and
  test your JMESPath expressions on the [official JMESPath
  website](https://jmespath.org/) before adding them to Data Fetcher.
</Note>

## **Common use cases and examples**

The examples below show how JMESPath can solve common data transformation challenges. In each case, the result is JSON that Data Fetcher can easily map to Airtable fields.

### **Keep only specific fields**

**Problem:** Your API returns too much data, and you only need a few fields.

**Sample JSON:**

```json
{
  "coins": [
    {
      "id": "bitcoin",
      "symbol": "btc",
      "name": "Bitcoin",
      "current_price": 27151
    },
    {
      "id": "ethereum",
      "symbol": "eth",
      "name": "Ethereum",
      "current_price": 1892
    }
  ]
}
```

**JMESPath Expression:** `coins[].{id:id, name:name}`

**Result:** Only the `id` and `name` fields are kept, reducing clutter in your Airtable base.

```json
[
  {
    "id": "bitcoin",
    "name": "Bitcoin"
  },
  {
    "id": "ethereum",
    "name": "Ethereum"
  }
]
```

**How it works:** In JMESPath, use `new_name:old_name` syntax inside curly braces to rename fields.

### **Filter data by conditions**

**Problem:** You only want records that meet specific criteria.

Use conditions with a question mark `?` followed by operators to filter your data:

| **Operator** | **Example JMESPath**                  | **Example in words**                                     |
| ------------ | ------------------------------------- | -------------------------------------------------------- |
| `==`         | `countries[?code == 'GB']`            | Keep objects where code equals GB                        |
| `>`          | `coins[?price > 100]`                 | Keep objects where price is greater than 100             |
| `>=`         | `coins[?price >= 100]`                | Keep objects where price is greater than or equal to 100 |
| `<`          | `coins[?price < 100]`                 | Keep objects where price is less than 100                |
| `<=`         | `coins[?price <= 100]`                | Keep objects where price is less than or equal to 100    |
| `&&`         | `coins[?price > 100 && price < 1000]` | Keep objects where price is between 100 and 1000         |

**Example:** To keep only coins worth more than \$100, use: `coins[?current_price > 100]`

### **Work with nested data**

**Problem:** The data you need is buried inside nested objects or arrays.

**Sample JSON with nested structure:**

```json
{
  "coins": [
    {
      "id": "bitcoin",
      "stats": {
        "current_price": 27105,
        "market_cap": 525583712973
      }
    }
  ]
}
```

**JMESPath Expression:** `coins[].{id:id, price:stats.current_price}`

**Result:** The nested `current_price` becomes a top-level `price` field.

```json
[
  {
    "id": "bitcoin",
    "price": 27105
  }
]
```

**How it works:** Use dot notation (`stats.current_price`) to access nested object properties.

### **Choose the right array**

**Problem:** Your JSON has multiple arrays, but Data Fetcher is using the wrong one.

**Sample JSON:**

```json
{
  "coins": [{ "id": "bitcoin", "current_price": 27105 }],
  "exchanges": [
    { "id": "ace", "name": "ACE" },
    { "id": "nominex", "name": "Nominex" }
  ]
}
```

**Solution:** Use `exchanges[]` to tell Data Fetcher to create records from the exchanges array instead of the coins array.

**Result:** The `exchanges` array is kept and becomes a top-level array.

```json
[
  {
    "id": "ace",
    "name": "ACE"
  },
  {
    "id": "nominex",
    "name": "Nominex"
  }
]
```

### **JMESPath syntax quick reference**

- **Arrays:** Access with `array_name[]`
- **Objects:** Access with `object_name.field_name`
- **Conditions:** Use `[?condition]` to filter arrays
- **Field selection:** Use `{new_name:old_name}` to pick and rename fields
- **Combine techniques:** Chain operations like `coins[?price > \`10`].{id:id, price:current_price}`

After applying a JMESPath expression, the Response field mapping will automatically refresh next time you run the request.
